# -*- coding: utf-8 -*-
"""Copia de CC3001 2023-1 Tarea 5

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HayJzPZqRdtkZ5h21Eye6JEwPcuy3CZ_

# CC3001 Otoño 2023 Tarea 5 [Victor Alfaro]

## ABBs posicionales

### Profesores
Sección 1 Iván Sipirán •
Sección 2 Nelson Baloian •
Sección 3 Patricio Poblete
"""

!pip install aed-utilities

import aed_utilities as aed
import numpy as np

"""## Introducción

Un *árbol de búsqueda binaria posicional* (*ABB posicional*) es un ABB modificado para que en cada nodo se agregue un campo adicional, que es un contador del número de llaves que hay en el subárbol que tiene a ese nodo como raíz, como se ve en el siguiente ejemplo:

![Ejemplo ABB posicional](https://www.dcc.uchile.cl/ppoblete/cc3001/ABBposicional.png)

Con esta información adicional, es posible, dado un valor de $k$, encontrar rápidamente el que sería el $k$-ésimo elemento, en un recorrido en inorden de izquierda a derecha ($k=1,\ldots,n$, donde $n$ es el número de llaves del árbol). Por ser un ABB, esto es lo mismo que encontrar el $k$-ésimo menor elemento del conjunto.

Llamaremos a esta operación ``find(k)``, la cual al ser ejecutada retorna un puntero al $k$-ésimo nodo interno, de izquierda a derecha. Si $k$ está fuera del rango $[1..n]$ se debe retornar ``None``.

Para implementar esta operación, comenzamos en la raíz y miramos el contador del hijo izquierdo. Si éste es mayor o igual que $k$, entonces el $k$-ésimo debe estar en el subárbol izquierdo, y lo seguimos buscando ahí recursivamente. Si $k$ es exactamente 1 más que el contador del hijo izquierdo, el elemento buscado es la raíz, así que retornamos un puntero a él. Por último, si no ha sido ninguno de los casos anteriores, el $k$-ésimo debe estar en el subárbol derecho, así que seguimos buscando ahí recursivamente. Pero, dentro de ese subárbol, el elemento buscado ya no es el $k$-ésimo, hay que restarle al $k$ una cantidad (¿cuánto?). Por ejemplo, si estábamos originalmente buscando el elemento con $k=5$, el que sería la llave "$62$", una vez que vamos a buscarlo dentro del subárbol derecho, dentro de ese árbol es el elemento con $k=2$.

## Objetivo de la tarea

Su trabajo consiste en implementar las clases ``Arbol``, ``Nodoi`` y ``Nodoe`` y los métodos ``insert``, ``search`` y ``find`` en todos lugares en donde corresponda (no se pide implementar ``delete``). Luego debe ejecutar los casos de prueba que se indica.

Note que la operación ``insert``, además de agregar la llave que se indica, debe modificar los contadores que sea necesario para que éstos reflejen correctamente los tamaños de los subárboles respectivos.

Esta tarea se puede resolver con recursividad o sin recursividad. Usted debe decidir cuál enfoque usar.

En el código que aparece a continuación usted debe agregar todo lo necesario para que la implementación esté completa.

_Nota_: El campo "``rep``" contiene la representación visual del nodo, que va a aparecer cuando se dibuje.
"""

class Nodoi:
    def __init__(self, izq, info, contador, der):
        self.izq = izq
        self.info = info
        self.contador = contador
        self.der = der
        self.rep = str(info) + ',' + str(contador)

    def search(self,x):
        if x==self.info:#Si el elemento que quiero buscar coincide con el nodo raiz, entonces devuelvo True
            return True
        if x<self.info:#Si el elemento que quiero ingresar es menos al info de la raiz, como es un ABB, debemos buscar recursivamente en el subarbol izq.
            return self.izq.search(x)
        else:
            return self.der.search(x )#Anologo a izq


    def insert(self,x):

        assert x!=self.info #Primero nos aseguramos que el elemento que queremos insertar sea distinto a los que ya estan
        if x<self.info: # Si x es menor a la info de la raiz, implica que tenemos que sumarle uno al contador porque necesariamente el padre tendra un hijo mas
            self.contador+=1
            return Nodoi(self.izq.insert(x),self.info,self.contador,self.der)#Creamos un nodo interno


        else:
            self.contador+=1 #Analogo
            return Nodoi(self.izq,self.info,self.contador,self.der.insert(x))



class Nodoe:
    def __init__(self, contador):
        self.contador = contador
        self.rep = contador

    def search(self,x): #Si al buscar encontramos un nodo interno quiere decir que el elemento no esta en el arbol
        return None

    def insert(self,x): #Si hay un nodo externo y queremos insertar un nodo interno, entonces reemplazamos el cuadrado por el valor
        return Nodoi(Nodoe(0),x,1,Nodoe(0))#del nodo que queremos insertar, poniendole un 1 como contador, con hijos izq y der nodos cuadrados.

class Arbol:
    def __init__(self, raiz=Nodoe(0)):
        self.raiz = raiz

    def insert(self,x):
        self.raiz=self.raiz.insert(x) #insertamos en las hojas no en la raiz, esto es importante de notar.

    def search(self, llave):#Busca una llave especifica
        return self.raiz.search(llave)#empezamos desde la raiz



    def find(self, k):#encuentra el k-esimo elemento
        return self.find_recursivo(self.raiz, k)

    def find_recursivo(self, nodo, k):
        if isinstance(nodo, Nodoe) or k <= 0 or k > nodo.contador: #Si el nodo actual es un nodo externo, o  k es menor o igual a cero, o  k es mayor que el contador del nodo actual, se devuelve None.
            return None
        if nodo.izq.contador >= k:#Si el contador del hijo izquierdo del nodo actual es mayor o igual a k, se busca en el subárbol izquierdo.
            return self.find_recursivo(nodo.izq, k)
        elif nodo.izq.contador + 1 == k: #Si el contador del hijo izquierdo del nodo actual más 1 es igual a k, se devuelve ese nodo.
            return nodo
        else:#se busca en el subárbol derecho
            return self.find_recursivo(nodo.der, k - nodo.izq.contador - 1)

    def dibujar(self):
      btd = aed.BinaryTreeDrawer(fieldData="rep", fieldLeft="izq", fieldRight="der", classNone=Nodoe)
      btd.draw_tree(self, "raiz")

"""Las siguientes funciones son útiles para probar su implementación:"""

def test_search(a,x):
    print(x, "está" if a.search(x) is not None else "no está")
def test_find(a,k):
    p=a.find(k)
    print("La k-ésima llave para k=",k, "es", p.info if p is not None else "fuera de rango")

"""## Prueba: Construir un árbol por inserciones sucesivas"""

a=Arbol()
a.insert(40)
a.insert(25)
a.insert(32)
a.insert(90)
a.insert(62)
a.insert(55)
a.insert(70)
a.dibujar()
test_search(a,62)
test_search(a,10)
test_find(a,5)
test_find(a,8)

"""## ¿Qué hay que entregar?

Usted debe crear una copia de este documento (del menú seleccionar "Archivo" o "File" y de ahi la opción "guardar copia en Drive" o "save a copy in Drive"). Este nuevo documento (notebook de Colab) es el que debe modificar para luego compartirlo con la opción "Cualquier usuario de internet con este enlace puede ver esto" (o “Anyone on the internet with this link can view”). Esta opción se encuentra disponible en la parte superior derecha de su notebook, en el botón "Compartir" (o "Share"). Una vez que tenga disponible el enlace, colocarlo en la descripción de la entrega de su tarea. No olvide colocar su nombre dentro del notebook.
"""