# -*- coding: utf-8 -*-
"""Copia de CC3001 - Oto√±o 2023 - Tarea1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11RlTopYJKCpdMDxhXdmHkHpsVD2KhK3e

# CC3001 Oto√±o 2023 Tarea 1

# Pilas de arena abelianas

### Profesores
Secci√≥n 1 Iv√°n Sipir√°n ‚Ä¢
Secci√≥n 2 Patricio Poblete ‚Ä¢
Secci√≥n 3 Nelson Baloian

# Introducci√≥n
El objetivo de esta tarea es estudiar un problema inspirado en un fen√≥meno f√≠sico, a trav√©s de un modelo matem√°tico, el cual si bien es sencillo, produce resultados que presentan una estructura muy interesante.

<img src="https://ivan-sipiran.com/downloads/arena.png" alt= ‚Äú‚Äù width="200">

La idea es que si uno va formando una pila de arena, llega un momento en que se produce un derrumbe, y la arena de esa pila se derrama hacia los lugares vecinos, estos a su vez se pueden derrumbar, y el proceso contin√∫a hasta que finalmente se estabiliza.

Para estudiar este proceso, usaremos un modelo ultra simplificado. Supondremos que la arena se deposita sobre una superficie plana, la cual est√° dividida en peque√±as celdas cuadradas, las cuales forman un tablero como se muestra en la siguiente figura:

<img src="https://ivan-sipiran.com/downloads/tablero.png" alt= ‚Äú‚Äù width="100">

El modelo supone que si se apilan demasiados granos de arena en una celda, se produce un derrumbe. En particular, la regla es que si en una celda hay 4 o m√°s granos, se le quitan 4 granos, que se reparten equitativamente hacia las celdas vecinas en los cuatro puntos cardinales.

Para simular este proceso, supondremos que cada celda almacena un n√∫mero entero, que es la cantidad de granos almacenados en su interior. Aplicando la regla antes descrita (y suponiendo que las celdas que aparecen vac√≠as tienen cero granos), desde la configuraci√≥n

<img src="https://ivan-sipiran.com/downloads/tablero1.png" alt= ‚Äú‚Äù width="100">

se pasar√≠a a

<img src="https://ivan-sipiran.com/downloads/tablero2.png" alt= ‚Äú‚Äù width="100">

Cuando hay m√°s de una casilla con exceso de granos de arena, la regla se puede aplicar a ellas en cualquier orden y el resultado final es el mismo. Esta propiedad es la que hace que estas pilas de arena se llamen abelianas.

La idea es partir desde una configuraci√≥n inicial, y luego aplicar esta regla en todos los casilleros que se pueda, hasta que no quede ninguno que tenga 4 o m√°s granos de arena. Esa configuraci√≥n final la vamos a visualizar asignando un color distinto a cada n√∫mero de granos.

En particular, nos va a interesar estudiar lo que ocurre cuando la configuraci√≥n inicial tiene todas las celdas vac√≠as, excepto la del centro, en la cual hay $N$ granos de arena (donde $N$ es un par√°metro del problema).

Note que en teor√≠a el tablero es infinito en el sentido que siempre hay espacio para colocar los granos de arena que se van distribuyendo. Para su simulaci√≥n, usted debe calcular un tama√±o del tablero lo suficientemente grande como para estar seguro que ning√∫n grano de arena se salga hacia afuera de los bordes (calcule la m√°xima √°rea que se puede cubrir con $N$ granos de arena, y despu√©s calcule cuan grande debe ser el tablero  para poder contener esa √°rea).

# Tarea

## Parte 1
Usted debe escribir una funci√≥n en Python llamada ``arena``, tal que dado un valor de $N$, simule el proceso anteriormente descrito hasta que se estabilice. El programa debe contar e imprimir el n√∫mero total de veces que se aplic√≥ la regla que distribuye granos de arena hacia los vecinos. Adem√°s, debe visualizar en la pantalla el tablero resultante, usando los m√©todos que se describen m√°s adelante.

Por ejemplo, al simular con $N=10000$, la figura que resulta es

<img src="https://ivan-sipiran.com/downloads/tablero3.png" alt= ‚Äú‚Äù width="250">

La idea va a ser ejecutar la funci√≥n con un valor de $N$ dado por el profesor ($N=128$) y luego con valores crecientes de $N$, hasta el mayor n√∫mero que pueda alcanzar dentro de un tiempo de ejecuci√≥n razonable.

Escriba a continuaci√≥n la definici√≥n de su funci√≥n:
"""

import matplotlib.pyplot as plt
import numpy as np
import math

def arena(N):
  r= int(math.sqrt(N / math.pi))  #Radio circulo

  diametro = int(r * 2.2)

  matriz=np.zeros((diametro,diametro)) #Creamos una matriz llena de ceros con un tama√±o tal que que queden todos los granos de arena dentro
  n=len(matriz)#Largo de la matriz

  contador1=0#Valor inicial del contador del numero de reglas
  matriz[int((n-1) /2)][int((n-1) /2)]=N #Posicionamos el N al centro de la matriz


  while np.max(matriz)>=4: #Condici√≥n suficiente para que el ciclo continue y no pare hasta que todos los granos de arena cumplan la regla
    for i in range(n): #Filas
      for j in range(n):#Columnas
        if matriz[i][j]>=4:

          matriz[i][j]=matriz[i][j]-4#Le restamos 4 a todos los elementos que cumplan el if
          contador1=contador1+1 #Vamos sumandole 1 al contador cada vez que se cumple la regla

          if i>0: #Condicion impuesta para que no haya problemas con los indices
            matriz[i-1][j]=matriz[i-1][j]+1 #norte

          if j>0:
            matriz[i][j-1]=matriz[i][j-1]+1 #oeste

          if i<n-1:
            matriz[i+1][j]=matriz[i+1][j]+1#sur

          if j<n-1:
            matriz[i][j+1]=matriz[i][j+1]+1#este


  plt.matshow(matriz)
  plt.show()
  return contador1

"""Explique aqu√≠ c√≥mo calcul√≥ el tama√±o que necesita tener el tablero.

$Teniendo$ $entonces$ $que$ $colocamos$ $N$ $granos$ $de$ $arena$ $en$ $el$ $centro$ $del$ $tablero,$ $y$ $teniendo$ $en$ $cuenta$ $tambien$ $las$ $reglas$ $definidas$ $con$ $anterioridad,$ $pongamonos$ $en$ $el$ $caso$ $donde$ $todos$ $los$ $granos$ $de$ $arena$ $estan$ $esparcidos$ $por$ $el$ $tablero$ $de$ $tal$ $forma$ $que$ $solo$ $hay$ $1$ $por$ $cada$ $cuadrado$ $del$ $tablero.$ $Este$ $seria$ $el$ $caso$ $mas$ $extremo$ $de$ $todos,$ $y$ $con$ $este$ $nos$ $quedaremos$ $porque$ $tenemos$ $una$ $cota$ $superior$ $muy$ $buena$ $para$ $el$ $tama√±o$ $de$ $la$ $matriz.$ $Ahora,$ $a$ $medida$ $que$ $el$ $N$ $va$ $aumentando$ $podemos$ $notar$ $que$ $se$ $forma$ $una$ $figura$ $reconocible,$ $un$ $circulo.$ $Este$ $lugar$ $geometrico$ $es$ $el$ $que$ $se$ $forma$ $a$ $medida$ $que$ $se$ $van$ $ejecutando$ $las$ $reglas,$ $por$ $lo$ $que$ $ahora$ $que$ $estamos$ $en$ $el$ $caso$ $mas$ $extremo,$ $podemos$ $decir$ $que$ $el$ $area$ $maxima$ $que$ $cubriran$ $N$ $granos$ $de$ $arena,$ $seria$ $una$ $circulo$ $de$ $cierto$ $radio$ $que$ $calcularemos$ $enseguida:$

$Area$ $maxima=$ $Pi*r**2=N,$ $donde$ $esta$ $igualdad$ $la$ $dedujimos$ $diciendo$ $que$ $cada$ $cuadrado$ $tiene$  $solo$ $un$ $grano$ $de$ $arena$ $formando$ $el$ $circulo.$ $($ $Asumimos$ $ademas$ $que$ $cada$ $grano$ $de$ $arena$ $tiene$ $una$ $unidad$ $de$ $area)$

$Por$ $lo$ $tanto,$ $despejando$ $r,$ $concluimos$ $que:$
$r=$ $sqrt(N / Pi)$

$Ya$ $teniendo$ $el$ $radio,$ $podemos$ $definir$ $el$ $tama√±o$ $de$ $la$ $matriz$ $de$ $ceros,$ $diciendo$ $que$ $para$ $cualquier$ $tama√±o$ $de$ $esta$ $que$ $sea$ $mayor$ $a$ $r,$ $podemos$ $cubrir$ $todo$ $el$ $circulo$ $que$ $cubren$ $los$ $granos$ $de$ $arena.$ $Por$ $lo$ $que$ $para$ $estar$  $($ $porque$ $pueden$ $haber$ $ciertos$ $errores$ $al$ $calcular$ $con$ $la$ $raiz),$ $eligimos$ $el$ $diametro,$ $es$ $decir,$ $dos$ $veces$ $el$ $radio,$ $y$ $as√≠,$ $se$ $elige$ $el$ $tama√±o$ $de$ $la$ $matriz.$

$En$ $conclusi√≥n:$

$Tama√±o$ $matriz> r,$
$Area= pi*r**2$

Ahora ejecute la funci√≥n para $N=128$:
"""

arena(128)

"""A continuaci√≥n ejecute la funci√≥n para el valor m√°s grande de $N$ que consiga alcanzar en un tiempo razonable:"""

arena(12000) # reemplace N por el valor m√°ximo que alcanz√≥ a procesar
#Se demoro 1 minuto con 42 segundos

"""## Parte 2
Observe que cuando en una celda hay un n√∫mero grande de granos de arena, es muy ineficiente ir quit√°ndole de 4 en 4, y ser√≠a mejor quitar de una sola vez lo m√°s que se pueda. Podemos mejorar nuestro programa si cambiamos la regla de distribuci√≥n, y decimos que si en una celda hay un n√∫mero de granos de arena mayor o igual a 4, le quitamos de una sola vez el mayor m√∫ltiplo de 4 posible, y todos esos granos lo repartimos equitativamente entre los vecinos de los cuatro puntos cardinales. Escriba una versi√≥n modificada de su funci√≥n de acuerdo a esta nueva regla.


"""

def arena2(N):
  r= int(math.sqrt(N / math.pi))  #Radio circulo

  diametro = int(r * 2.2)

  matriz=np.zeros((diametro,diametro)) #Creamos una matriz llena de ceros con un tama√±o tal que que queden todos los granos de arena dentro
  n=len(matriz)#Largo de la matriz

  contador2=0#Valor inicial del contador del numero de reglas
  matriz[int((n-1) /2)][int((n-1) /2)]=N #Posicionamos el N al centro de la matriz


  while np.max(matriz)>=4: #Condici√≥n suficiente para que el ciclo continue y no pare hasta que todos los granos de arena cumplan la regla
    for i in range(n): #Filas
      for j in range(n):#Columnas
        if matriz[i][j]>=4:





          contador2=contador2+1 #Vamos sumandole 1 al contador cada vez que se cumple la regla

          if i>0: #Condicion impuesta para que no haya problemas con los indicies
             #norte
              matriz[i-1][j]+=matriz[i][j]//4

          if j>0:
               matriz[i][j-1]+=matriz[i][j]//4#oeste

          if i<n-1:
               matriz[i+1][j]+=matriz[i][j]//4#sur

          if j<n-1:
               matriz[i][j+1]+=matriz[i][j]//4#este

          matriz[i][j]%=4 #Resto de la divisi√≥n por 4 entrega el valor final de un elemento de la matriz



  plt.matshow(matriz)
  plt.show()
  return contador2   #Retonarmos la matriz final y el valor del contador como una tupla

"""Ahora ejecute la funci√≥n para $N=128$:"""

arena2(128)

"""A continuaci√≥n ejecute la funci√≥n para el valor m√°s grande de  ùëÅ  que consiga alcanzar en un tiempo razonable. Note que √©ste n√∫mero no necesariamente es el mismo que para la funci√≥n anterior:"""

arena2(30000) # reemplace N por el valor m√°ximo que alcanz√≥ a procesar
#se demor√≥ 2 minutos y 9 segundos

"""## Parte 3
Compare a trav√©s de una tabla y un gr√°fico el n√∫mero de aplicaciones de la regla que hace el programa en la Parte 1 y el de la Parte 2, para los distintos valores de $N$ que usted haya calculado.

Discuta si vali√≥ la pena la optimizaci√≥n y discuta tambi√©n (pero no implemente) otras posibles optimizaciones que se le ocurran.

$A$ $continuaci√≥n$ $compararemos$ $cada$ $valor$ $del$ $contado$ $para$ $cada$ $una$ $de$ $las$ $versiones$ $de$ $la$ $funci√≥n$.
"""

import matplotlib.pyplot as plt

fig, ax = plt.subplots()
N = [10,100,500, 1000,5000,10000,20000]
Funciones = {'Arena1':[2,225,4702,18226,466188,1830917,7274878], 'Arena2':[1,149,3031,11724,307656,1196817,4746155]}
ax.plot(N, Funciones['Arena1'], label = 'Arena1',marker='o')
ax.plot(N, Funciones['Arena2'], label = 'Arena2',marker='o')
ax.legend(loc = 'upper left')
ax.set_xlabel("N", fontdict = {'fontsize':14, 'fontweight':'bold', 'color':'tab:blue'})
ax.set_ylabel("Valor del contador")
ax.set_title('Comparaci√≥n de los contadores', loc = "left", fontdict = {'fontsize':14, 'fontweight':'bold', 'color':'tab:blue'})


plt.show()

"""Arena 1

| N     | Contador |
|-------|----------|
| 10    | 2        |
| 100   | 225      |
| 500   | 4702     |
| 1000  | 18226    |
| 5000  | 466188   |
| 10000 | 1830917  |
| 20000 | 7274878  |



Arena 2

| N     | Contador |
|-------|----------|
| 10    | 1        |
| 100   | 149      |
| 500   | 3031     |
| 1000  | 11724    |
| 5000  | 307656   |
| 10000 | 1196817  |
| 20000 | 4746155  |

**Analizando el grafico y la tabla podemos apreciar que para valores peque√±os de N tales como 1000 o 5000, no hay un gran margen de diferencia entre ambas funciones, es decir, el tiempo de ejecuci√≥n de arena2 no es tan diferente al de arena 2 como para decir que efectivamente vale la pena haber hecho esta optimizaci√≥n. Pero esto cambia cuando N es mas grande. Para valores desde 10000 en adelante, hay una diferencia notoria en los contadores de cada uno, lo que se traduce en un tiempo de ejecuci√≥n muy alto para arena1, y abajo para 2, lo cual, puede ser crucial para situaciones donde se requiera que se entregue el resultado en el menor tiempo posible. En resumen:
P√°ra N peque√±o: Es practicamente lo mismo usar uno o el otro;
Para N grande: Es mucho mas eficiente usar arena2**

**Ahora, para aumentar la eficiencia del algoritmo, podriamos en vez de usar iteraciones, usar recursi√≥n, aunque no necesariamente puede que aumente la eficiencia, no esta demas intentarlo y quizas salga en menos lineas de codigo. Otra forma de aumentar la eficincia puede ser ver ciclos que se formen al tener 4 granos, de tal forma que se implente un if tal que se ejecute una instrucci√≥n que haga que se tenga todo en un solo paso y no en varios.**
"""
